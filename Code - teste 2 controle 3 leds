#include <WiFi.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <Update.h>

// Credenciais da rede WiFi
const char* ssid = "INTELBRAS - JOAO";
const char* password = "jps510123";

// Detalhes do servidor MQTT
const char* mqtt_server = "18dd6a02029d4d7781deed1e012e3fc2.s1.eu.hivemq.cloud";
const char* mqtt_username = "pedroteste";
const char* mqtt_password = "Pedro510123.";
const int mqtt_port = 8883;

// URL base para atualizações de firmware
const char* firmware_base_url = "https://raw.githubusercontent.com/PedroKutski/TESTES/main/";

// Pinos dos LEDs
const int ledPin = 2;
const int ledPin5 = 5;
const int ledPin18 = 18;
const int ledPin19 = 19;

// Clientes WiFi e MQTT
WiFiClientSecure espClient;
PubSubClient mqttClient(espClient);

// Declarações de funções
void reconnectToMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
void blinkLED(int times, int delayTime);
void downloadFirmware(const String& filename);

void setup() {
  Serial.begin(9600); // Inicializa a comunicação serial a 9600 bps
  pinMode(ledPin, OUTPUT); // Define o pino do LED como saída
  pinMode(ledPin5, OUTPUT); // Define o pino 5 como saída
  pinMode(ledPin18, OUTPUT); // Define o pino 18 como saída
  pinMode(ledPin19, OUTPUT); // Define o pino 19 como saída
  WiFi.begin(ssid, password); // Conecta-se à rede WiFi
  while (WiFi.status() != WL_CONNECTED) delay(500); // Aguarda a conexão
  espClient.setInsecure(); // Desabilita a verificação do certificado SSL
  mqttClient.setServer(mqtt_server, mqtt_port); // Define o servidor e a porta MQTT
  mqttClient.setCallback(mqttCallback); // Define a função de callback do MQTT
}

void loop() {
  if (!mqttClient.connected()) reconnectToMQTT(); // Reconecta ao MQTT se desconectado
  mqttClient.loop(); // Processa mensagens MQTT
}

void reconnectToMQTT() {
  while (!mqttClient.connected()) {
    if (mqttClient.connect("ESP32Client", mqtt_username, mqtt_password)) {
      mqttClient.subscribe("firmgit"); // Inscreve-se no tópico de atualização de firmware
      mqttClient.subscribe("ledcontrol"); // Inscreve-se no tópico de controle do LED
    } else {
      delay(5000); // Aguarda 5 segundos antes de tentar novamente
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String message = String((char*)payload).substring(0, length); // Converte o payload para string
  if (String(topic) == "firmgit") {
    blinkLED(3, 500); // Pisca o LED 3 vezes para indicar atualização de firmware
    downloadFirmware(message); // Baixa e aplica a atualização de firmware
  } else if (String(topic) == "ledcontrol") {
    if (message == "2 on") {
      digitalWrite(ledPin, HIGH); // Liga o LED no pino 2
    } else if (message == "2 off") {
      digitalWrite(ledPin, LOW); // Desliga o LED no pino 2
    } else if (message == "5 on") {
      digitalWrite(ledPin5, HIGH); // Liga o LED no pino 5
    } else if (message == "5 off") {
      digitalWrite(ledPin5, LOW); // Desliga o LED no pino 5
    } else if (message == "18 on") {
      digitalWrite(ledPin18, HIGH); // Liga o LED no pino 18
    } else if (message == "18 off") {
      digitalWrite(ledPin18, LOW); // Desliga o LED no pino 18
    } else if (message == "19 on") {
      digitalWrite(ledPin19, HIGH); // Liga o LED no pino 19
    } else if (message == "19 off") {
      digitalWrite(ledPin19, LOW); // Desliga o LED no pino 19
    }
  }
}

void blinkLED(int times, int delayTime) {
  for (int i = 0; i < times; i++) {
    digitalWrite(ledPin, HIGH); // Liga o LED
    delay(delayTime); // Aguarda
    digitalWrite(ledPin, LOW); // Desliga o LED
    delay(delayTime); // Aguarda
  }
}

void downloadFirmware(const String& filename) {
  String firmwareUrl = firmware_base_url + filename; // Constrói a URL do firmware
  WiFiClientSecure client;
  client.setInsecure(); // Desabilita a verificação do certificado SSL
  HTTPClient http;
  http.begin(client, firmwareUrl); // Inicializa o cliente HTTP com a URL do firmware
  int httpCode = http.GET(); // Envia a requisição GET

  if (httpCode == HTTP_CODE_OK) {
    int contentLength = http.getSize(); // Obtém o tamanho do conteúdo
    if (contentLength > 0 && Update.begin(contentLength)) {
      size_t written = Update.writeStream(*http.getStreamPtr()); // Escreve o firmware na memória flash
      if (written == contentLength && Update.end() && Update.isFinished()) {
        blinkLED(1, 3000); // Pisca o LED para indicar atualização bem-sucedida
        ESP.restart(); // Reinicia o ESP32
      }
    }
  }
  http.end(); // Encerra a conexão HTTP
}
